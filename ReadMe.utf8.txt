Cоздано специально для twirpx.com.

Здесь нами реализован простой HTTP сервер для *nix систем. Сервер выполнен
в виде консольной утилиты. Для запуска сервера достаточно ввести в консоли:
	> server

Сервер получает запрос от клиента (браузера) GET запрос.
Для этого надо ввести адрес сервера в строке адреса, например
	http://127.0.0.1:7070/

После этого сервер отправляет клиенту ответ вида:
	Request (<количество подключений>):
	<GET запрос от клиента>

Например:

	Request (5):

	GET / HTTP/1.1
	Host: 127.0.0.1:7070
	User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:6.0)
												Gecko/20100101 Firefox/6.0
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
	Accept-Language: en-us,en;q=0.5
	Accept-Encoding: gzip, deflate
	Connection: keep-alive
	Cookie: csrftoken=1708e00b9f6b99d3d03da550d41a11e0
	Cache-Control: max-age=0


Сервер может работать с несколькими клиентами одновременно.
Кроме того, сервер обладает рядом параметров, которые задаются через 
аргументы командной строки.

	-p<PORT> 	или --port=<PORT>	задает порт на котором работает сервет.
										По-умолчанию 7070.
	-l<LOG> 	или --log=<LOG>		задает файл, в который сервер записывает log
										По-умолчанию log.txt.										
	-h<LOG> 	или --help			показывает справку.

Для сборки сервера воспользуйтесь:
	> make

В Makefile определены макросы условной компиляции.
	DEFINES := -DDEBUG -DTEST

При включенном макросе DEBUG в поток ошибок (stderr, 2>) будет выводиться
отладочная информация. При включенном макросе TEST, каждый запрос будет ждать
10 секунд, прежде чем его передадут обратно клиенту.

Предложения

Текущая реализация сервера является не самой эффективной из возможных,
для улучшения эффективности, можно попробовать все переписать на чистые C.

Параллельная обработка нескольких запросов от клиентов реализована 
через системный вызов fork(). 
В данном случае, тоже можно было пойти по другому пути:
	1) Воспользоваться вызовом Popen2.
	2) Воспользоваться потоками.
	3) Воспользоваться сторонними стредсвами Boost или Qt.
	
Взаимодействие процессов между собой реализовано через разделяемую память.
В процессе решения задачи очень хочется написать аллокатор для контейнеров STL,
для работы с разделяемой памятью, но в данном случае это излишне, и может
привести к существенным накладным расходам.
Использование разделяемой памяти в данном случае, тоже не является необходимым.
Без нее можно переодически обращаться к файлу логов и вынимать всю информацию 
оттуда. Однако такой подход будет медленне.

Кроме того, всего скорее требуется дополнительный анализ кода на предмет
утечек памяти и их устранение.
